#+TITLE: Functional Programming and Test Driven Development
#+AUTHOR:    Bas Bossink
#+EMAIL:     bas.bossink@gmail.com
#+LANGUAGE:  en
#+OPTIONS:   num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+STARTUP: 
* Functional Programming and Test Driven Development
** 0-5 Intro Scheme 
*** Why Scheme?
- purly functional
- dynamically typed
- almost no syntax, easy to explain
- small
- different from what we usually use
*** Scheme is a LISP dialect
- (LISt Processing)
- the second high level language
- created in 1958.
- garbage collected
- Scheme created by Guy Steele and Gerald Sussman at MIT
- Scheme introduced throug a series of papers from 1975-1980
- Standardized by IEEE
- Most widely used R5RS Revised Report on the Algorithmic Language
  Scheme 1998
*** Who are you?
**** Who has ever used a functional language?
**** Who has ever used a LISP dialect?
**** Who has experience with TDD?
**** Who uses TDD an a day to day basis?
** 5-15 Scheme the language
*** Numbers
- integers and floating point numbers look like you would expect
*** Strings
- are delimeted by double quotes
*** Symbols
- Symbols can be thought of as labels that can be easily compared
- Symbols are interned strings that can be compared by pointer
  comparison
*** Lists
-The list is the central datastructure of the syntax and the language
***** Definition
- '(' elem elem ')'
- repl:
#+BEGIN_SRC scheme
 (1 2 3)
#+END_SRC
- the first element is interpreted as a procedure name or syntactic
  form, the rest of the list are the arguments
- repl: (+ 1 2 3)
***** Creating lists
- repl: (list 1 2 3)
- repl: (quote (1 2 3))
- repl '(1 2 3)
***** Building lists from elements
- repl: (cons 1 (cons 2 (cons 3 '())))
- repl: (cons 1 2)
***** Deconstructing lists
- repl: (car '(1 2 3))
- repl: (cdr '(1 2 3))
*** Definitions, Bindings
- repl: (define square-it (lambda (x) (* x x)))
- repl: (square-it 2)
- repl: (define fred 37)
- repl: (square-it fred)
*** Creating functions, Lambda expressions
- repl: (lambda (x) (* x x))
- repl: ((lambda (x) (* x x)) 2)
- repl: (lambda (x y) (+ x y) 26 11)
*** if, cond
- repl: (if #t 2 3)
- repl: (if #f 2 3)
- repl: 
#+BEGIN_SRC scheme
  (define abs 
    (lambda (x) 
      (cond ((< x 0) (- x))
            ((> x 0) x)
            (else 0))))
#+END_SRC scheme
*** Tests
- repl: (load "~/.bin/check.scm")
- repl: (check 3 => 3)
- repl: (check "Fred" => "Barney")
** 15-20 Test Driven Development
*** Three rules of test driven development:
1. You are not allowed to write any production code unless it is to
   make a failing unit test pass.
2. You are not allowed to write any more of a unit test than is
   sufficient to fail; and compilation failures are failures.
3. You are not allowed to write any more production code than is
   sufficient to pass the one failing unit test.
*** Setup for this workshop
- for simplicity we will write the production and test code in the
  same file
***** Running tests
- prompt: run-tests
- automatic prompt watchr run-tests.watchr

** 20-50 Fizzbuzz
*** 20-35 Simple fizzbuzz 
For a given natural number greater zero return
- "fizz" if the number is dividable by 3
- "buzz" if the number is dividable by 5
- "fizzbuzz" if the number is dividable by 3 and 5
*** 35-45 Refactor the test code
- Minimize repitition in the test code by extracting a method
- Rewrite the test cases as a list and use the map function to 
  apply your test function to each of the test cases.
*** 45-50 Plenair show dried up test code
- use of the exctract function
- use of the apply function
