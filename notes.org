#+TITLE: Functional Programming and Test Driven Development
#+AUTHOR:    Bas Bossink
#+EMAIL:     bas.bossink@gmail.com
#+LANGUAGE:  en
#+OPTIONS:   num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+STARTUP: 
* Functional Programming and Test Driven Development
** 0-5 Intro Scheme 
*** Why Scheme?
- purly functional
- dynamically typed
- almost no syntax, easy to explain
- small
** 5-15 Scheme the language
*** Scheme is a LISP dialect (LISt Processing)
*** The list is the central datastructure of the syntax and the language
***** Definition
- '(' elem elem ')'
- repl:
#+BEGIN_SRC scheme
 (1 2 3)
#+END_SRC
- the first element is interpreted as a procedure name or syntactic
  form, the rest of the list are the arguments
- repl: (+ 1 2 3)
***** Creating lists
- repl: (list 1 2 3)
- repl: (quote (1 2 3))
- repl '(1 2 3)
***** Building lists from elements
- repl: (cons 1 (cons 2 (cons 3 '())))
- repl: (cons 1 2)
***** Deconstructing lists
- repl: (car '(1 2 3))
- repl: (cdr '(1 2 3))
*** Creating functions, Lambda expressions
- repl: (lambda (x) (* x x))
- repl: ((lambda (x) (* x x)) 2)
- repl: (lambda (x y) (+ x y) 26 11)
*** Definitions, Bindings
- repl: (define square-it (lambda (x) (* x x)))
- repl: (square-it 2)
- repl: (define fred 37)
- repl: (square-it fred)
*** Local bindings
-repl: (let ((a 4) (b 3)) (* a b))
-repl: (let ((a 4) (b (* a a))) (* a b))
-repl: (letrec ((a 4) (b (* a a))) (* a b))
-repl:
#+BEGIN_SRC scheme
  (define length 
    (lambda (x y) 
      (let ((square 
             (lambda (x) (* x x)))) 
        (sqrt (+ (square x) (square y))))))
#+END_SRC
- repl:
#+BEGIN_SRC scheme
  (define root 
    (lambda (a b c) 
      (let ((disc (- (* b b) (* 4 a c)))
            (denom (* 2 a))) 
        (list 
         (/ (+ (- b) (sqrt disc)) denom) 
         (/ (- (- b) (sqrt disc)) denom)))))
#+END_SRC
*** if, cond
- repl: (if #t 2 3)
- repl: (if #f 2 3)
- repl: 
#+BEGIN_SRC scheme
  (define abs 
    (lambda (x) 
      (cond ((< x 0) (- x))
            ((> x 0) x)
            (else 0))))
#+END_SRC scheme
*** Tests
- repl: (require-extension test)
- repl: (test 37 (+ 33 3))
- repl: (test "Fred" "Barney")
- repl: (test-assert #f)
- repl: (test-error #f)
- repl: (test-error (a b))
** 15-20 Test Driven Development
*** Three rules of test driven development:
1. You are not allowed to write any production code unless it is to
   make a failing unit test pass.
2. You are not allowed to write any more of a unit test than is
   sufficient to fail; and compilation failures are failures.
3. You are not allowed to write any more production code than is
   sufficient to pass the one failing unit test.
*** Setup for this workshop
- for simplicity we will write the production and test code in the
  same file
***** Running tests
- prompt: run-tests
- automatic prompt watchr tests.watchr
- the test module is already loaded for you so no require statement is
  needed

** 20-50 Fizzbuzz
*** 20-35 Simple fizzbuzz 
For a given natural number greater zero return
- "fizz" if the number is dividable by 3
- "buzz" if the number is dividable by 5
- "fizzbuzz" if the number is dividable by 3 and 5
*** 35-45 Refactor the test code
- Minimize repitition in the test code by extracting a method
- Rewrite the test cases as a list and use the map function to 
  apply your test function to each of the test cases.
*** 45-50 Plenair show dried up test code
- use of the let bindings
- use of the exctract function
- use of the apply function
